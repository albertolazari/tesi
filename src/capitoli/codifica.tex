\section{Modelli}
La codifica dei modelli passa per tre fasi successive:
\begin{enumerate}
	\item creazione della entità del modello nel database e della classe, utilizzando le migrazioni;
	\item l'associazione del modello con altri modelli o elementi di \emph{storage};
	\item le validazioni sugli attributi e sulle associazioni dichiarate.
\end{enumerate}

\subsection{Migrazioni del database}
Basandosi su quanto definito nella fase di progettazione dei modelli, descritta nel capitolo \ref{cap:modelli}, questi sono stati generati utilizzando da linea di comando il generatore automatico \verb|rails generate model| o, in versione ridotta, \verb|rails g model|. Il comando accetta come argomenti:
\begin{itemize}
	\item il nome del modello, al singolare e in \emph{CamelCase};
	\item gli attributi che deve avere il modello;
	\item per ogni attributo: il suo tipo, che rispecchia, ad alto livello, i tipi comunemente disponibili per le colonne nei DBMS SQL. Normalmente è uno dei seguenti tipi nativi delle migrazioni di Rails \footcite{site:migration-types}, agnostici rispetto all'implementazione del database:
	\begin{itemize}
		\item \verb|primary_key|,
		\item \verb|string|,
		\item \verb|text|,
		\item \verb|integer|,
		\item \verb|bigint|,
		\item \verb|float|,
		\item \verb|decimal|,
		\item \verb|datetime|,
		\item \verb|timestamp|,
		\item \verb|time|,
		\item \verb|date|,
		\item \verb|binary|,
		\item \verb|blob|,
		\item \verb|boolean|,
		\item \verb|references|
	\end{itemize}
	\item per ogni attributo: l'identificatore \verb|uniq|, che imposta un indice su quella colonna del database, che ne specifica l'unicità nell'entità.
\end{itemize}
Di conseguenza, la sintassi generale è la seguente:
\begin{minted}{shell}
rails g model ModelName attr_1:type:[uniq] attr_2:type:[uniq] ...
\end{minted}
Portando un esempio reale, per la generazione del modello degli organizzatori è stato usato il comando seguente:
\begin{minted}{shell}
rails g model Organizer name:string vat:string:uniq sdi:string:uniq address:string city:string country:string zip_code:string status:integer email:string email_pec:string phone:string finished_webhook:string add_participant_webhook:string remove_participant_webhook:string platform:references creator_id:bigint
\end{minted}
che ha prodotto la seguente migration:
\begin{minted}{ruby}
# db/migrate/{timestamp}_create_organizers.rb

class CreateOrganizers < ActiveRecord::Migration[7.0]
	def change
	create_table :organizers do |t|
		t.string :name
		t.string :vat
		t.string :sdi
		t.string :address
		t.string :city
		t.string :country
		t.string :zip_code
		t.integer :status
		t.string :email
		t.string :email_pec
		t.string :phone
		t.string :finished_webhook
		t.string :add_participant_webhook
		t.string :remove_participant_webhook
		t.references :platform, foreign_key: true
		t.bigint :creator_id

		t.timestamps
	end
	add_index :organizers, :vat, unique: true
	add_index :organizers, :sdi, unique: true
	end
end
\end{minted}
Successivamente questa è stata modificata, aggiungendo i vincoli \verb|NOT NULL|, la chiave esterna verso l'utente creatore e il valore di default per il ruolo, prima di eseguire effettivamente la migrazione.

Si noti come non sia necessario specificare la chiave primaria. Il comportamento di \emph{default} di Active Record è introdurre automaticamente un identificativo progressivo, chiamato \verb|id|, di tipo \verb|bigint|. Inoltre \verb|timestamps| genera automaticamente degli attributi gestiti dalla gemma, per tracciare l'istante di creazione e ultima modifica dei record.

La migrazione definitiva è stata la seguente:
\begin{minted}{ruby}
# db/migrate/{timestamp}_create_organizers.rb

class CreateOrganizers < ActiveRecord::Migration[7.0]
  def change
    create_table :organizers do |t|
      t.string :name, null: false
      t.string :vat, null: false
      t.string :sdi, null: false
      t.string :address, null: false
      t.string :city, null: false
      t.string :country, null: false
      t.string :zip_code, null: false
      t.integer :status, null: false, default: Organizer.statuses[:active]
      t.string :email
      t.string :email_pec
      t.string :phone
      t.string :finished_webhook
      t.string :add_participant_webhook
      t.string :remove_participant_webhook
      t.references :platform, null: false, foreign_key: true
      t.bigint :creator_id, null: false

      t.timestamps
    end
    add_foreign_key :organizers, :users, column: :creator_id
    add_index :organizers, :vat, unique: true
    add_index :organizers, :sdi, unique: true
  end
end
\end{minted}
Utilizzando il metodo \verb|change|, le migrazioni possono modificare la struttura del database secondo quando specificato nella migrazione, senza necessità di ricorrere a \emph{downtime} del server e di eseguire il rollback alla versione dello schema del database precedente, se fosse necessario.

Il generatore produce altri due file, oltre alla migrazione:
\begin{minted}{ruby}
# app/models/organizer.rb
class Organizer < ActiveRecord::Base
  belongs_to :platform
end

# spec/models/organizer_spec.rb
require 'rails_helper'

RSpec.describe Organizer, type: :model do
  pending "add some examples to (or delete) #{__FILE__}"
end
\end{minted}
Il primo contiene la definizione della classe, in cui andranno inseriti i metodi, le validazioni e le associazioni sul modello, descritte in \S \ref{code:association} e \S \ref{code:validates}.\ Nel secondo andranno definiti i test di unità per il modello, descritti in \S \ref{code:spec}.

\subsection{Associazioni a modelli e file} \label{code:association}
Una volta generata la struttura del modello attraverso le migrazioni del database, è stato necessario associare tra loro i modelli, al livello dell'applicazione, secondo le relazioni espresse nel diagramma ER prodotto durante la fase di analisi e refactor (\S \ref{cap:modelli}). Per farlo, sono stati utilizzati i metodi forniti da \verb|ActiveRecord::Base|, classe ereditata da tutti i modelli. Nel progetto, in realtà, tutti i modelli ereditano da \verb|ApplicationRecord|, che a sua volta eredita da \verb|ActiveRecord::Base|, ma viene utilizzato per aggiunge metodi di utilità a tutti i modelli implementati.

Rails incentiva l'implementazione di associazioni bidirezionali, attraverso l'utilizzo dei metodi:
\begin{itemize}
	\item \verb|belongs_to|: utilizzato per specificare l'associazione con il modello di cui la classe memorizza la chiave esterna;
	\item \verb|has_one|: specifica l'associazione con un record di un modello che memorizza la chiave esterna alla classe;
	\item \verb|has_many|: specifica l'associazione con più record di un modello che memorizza la chiave esterna alla classe;
	\item \verb|has_and_belongs_to_many|: permette di specificare associazioni del tipo ``molti a molti'', utilizzando una tabella, creata manualmente, che possiede le chiavi esterne ad entrambi i modelli coinvolti.
\end{itemize}
Oltre alle associazioni con i modelli sono state specificate le associazioni con i file. Queste vengono gestite con la gemma Active Storage, che fornisce i metodi per eseguire l'associazione (\emph{attach}) dei file, chiamati \emph{attachments}: \verb|has_one_attached| e \verb|has_many_attached|.

Proseguendo con l'esempio dell'implementazione degli organizzatori, il file della classe \verb|Organizer| con le associazioni dichiarate risulta essere il seguente:
\begin{minted}{ruby}
class Organizer < ApplicationRecord
  belongs_to :platform
  belongs_to :creator, class_name: 'User', inverse_of: :created_organizers, optional: true

  has_many :users, dependent: :nullify
  has_one :managed_platform, class_name: 'Platform', inverse_of: :main_organizer, dependent: :nullify
  has_many :locations, dependent: :nullify

  has_one_attached :logo
end
\end{minted}

\subsection{Validazioni} \label{code:validates}
\intro{Validazioni sugli attributi del modello e le associazioni.}

\section{Controller}
\subsection{APIController}
\intro{Descrizione dei metodi di utilità ereditati dai controller dell'API.}

\subsection{Implementazione delle action}
\intro{Descrizione ed esempio di action tipiche dei controller.}

\section{Gestione dei permessi}
\intro{Funzionamento e uso della gemma ``Pundit'' per la gestione dei permessi relativi agli endpoint dell'API, scope e metodi relativi alle action, esempio di gestione della gerarchia che andrà rivisto}

\section{Test di unità} \label{code:spec}
\intro{Descrizione della gemma ``RSpec'', che fornisce strumenti per lo sviluppo guidato dal comportamento (behaviour-driven development), esempi di modelli testati.}
